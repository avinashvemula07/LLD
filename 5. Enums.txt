Below is a **polished, course-ready rewrite** of your Enums section.
It matches the tone and structure of professional OOP / LLD course notes and flows naturally from the previous “Classes and Objects” chapter.

---

# Enums (Enumerations)

Enums—short for **enumerations**—are a powerful yet often underappreciated feature in object-oriented design. They allow you to define a **fixed set of named constants**, making your code more expressive, type-safe, and easier to maintain.

When used correctly, enums:

* Eliminate ambiguity
* Reduce bugs
* Make intent explicit
* Improve long-term maintainability

---

## What Is an Enum?

An **enum** is a special data type that defines a **finite collection of constant values** under a single type.

Unlike primitive constants or raw strings, enums are **type-safe**. This means a variable declared as an enum type can only hold one of the predefined values—nothing else.

> **Rule of thumb:**
> If a variable can take *only one value from a known, fixed set*, use an enum.

---

## Why Use Enums?

Enums provide several advantages over plain constants or string literals:

### 1. Avoid “Magic Values”

Enums eliminate scattered strings or numbers such as `"PENDING"` or `3`, which are easy to mistype and hard to reason about.

### 2. Improve Readability

Code becomes self-explanatory:

```python
OrderStatus.SHIPPED
```

is far clearer than:

```python
"SHIPPED" or 3
```

### 3. Enforce Type Safety

The compiler (or interpreter + IDE) ensures only valid enum values are used, catching errors early.

### 4. Better IDE Support

Enums work well with:

* Auto-completion
* Refactoring tools
* Static analysis

### 5. Reduce Bugs

Invalid values cannot be accidentally assigned. This alone prevents an entire class of runtime bugs.

---

## Common Use Cases for Enums

Enums are ideal for modeling categories or states that **rarely change**:

* **Order States**: `PLACED`, `CONFIRMED`, `SHIPPED`, `DELIVERED`
* **User Roles**: `ADMIN`, `CUSTOMER`, `DRIVER`
* **Vehicle Types**: `CAR`, `BIKE`, `TRUCK`
* **Directions**: `NORTH`, `SOUTH`, `EAST`, `WEST`

By using enums instead of raw strings or integers, your system becomes easier to understand and harder to misuse.

---

## Code Examples

### Simple Enum

Consider an e-commerce application where an order can exist only in a fixed set of states.

```python
from enum import Enum

class OrderStatus(Enum):
    PLACED = "PLACED"
    CONFIRMED = "CONFIRMED"
    SHIPPED = "SHIPPED"
    DELIVERED = "DELIVERED"
    CANCELLED = "CANCELLED"
```

This enum explicitly defines **all valid order states**. No other value is allowed.

#### Using the Enum

```python
status = OrderStatus.SHIPPED

if status == OrderStatus.SHIPPED:
    print("Your package is on the way!")
```

This is safer and more expressive than checking strings or numeric codes.

---

## Enums with Properties and Methods

Enums can do more than just hold constant values.
They can also encapsulate **data and behavior**, making them even more powerful.

### Example: Enum with Behavior

Let’s model U.S. coins and their denominations.

```python
from enum import Enum

class Coin(Enum):
    PENNY = 1
    NICKEL = 5
    DIME = 10
    QUARTER = 25

    def __init__(self, value):
        self._value = value

    def get_value(self):
        return self._value
```

Each enum constant:

* Represents a specific coin
* Stores its denomination
* Exposes behavior through methods

#### Using the Enum

```python
total = Coin.DIME.get_value() + Coin.QUARTER.get_value()
print(total)  # 35
```

This approach is:

* More readable
* More maintainable
* Safer than using raw integers

---

## When (Not) to Use Enums

### Use Enums When:

* The set of values is fixed and known in advance
* Values represent states, roles, or categories
* You want compile-time or IDE-level validation

### Avoid Enums When:

* Values are dynamic or user-defined
* New values are added frequently at runtime
* Data is better modeled as entities or database records

---

## Key Takeaway

Enums give structure to your data by clearly defining **what values are allowed** and **what values are not**.

They:

* Replace magic values
* Improve clarity
* Enforce correctness by design

However, enums are about *values*, not *behavioral contracts*.

When you need to define a **common set of behaviors** that different classes can implement in their own way, you need a different abstraction.

➡️ **Next Chapter:** *Interfaces — Defining Behavioral Contracts*
